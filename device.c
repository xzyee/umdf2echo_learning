#include "driver.h"

NTSTATUS
EchoDeviceCreate(
    PWDFDEVICE_INIT DeviceInit
    )
/*++
    DeviceInit - Pointer to an opaque init structure. Memory for this
                 structure will be freed by the framework when the WdfDeviceCreate
                 succeeds. So don't access the structure after that point.
--*/
{
    WDF_OBJECT_ATTRIBUTES   deviceAttributes;
    PDEVICE_CONTEXT deviceContext; //绝对不会是句柄
    WDF_PNPPOWER_EVENT_CALLBACKS    pnpPowerCallbacks;//注意是一堆回调，不是一个
    WDFDEVICE device;//句柄，你信吗？
    NTSTATUS status;

	  //第一步：初始化WDF_PNPPOWER_EVENT_CALLBACKS
    
    WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);//清零

    //
    // Register pnp/power callbacks so that we can start and stop the timer as the device
    // gets started and stopped.
    //
    pnpPowerCallbacks.EvtDeviceSelfManagedIoInit    = EchoEvtDeviceSelfManagedIoStart;
    pnpPowerCallbacks.EvtDeviceSelfManagedIoSuspend = EchoEvtDeviceSelfManagedIoSuspend;
	  pnpPowerCallbacks.EvtDeviceSelfManagedIoRestart = EchoEvtDeviceSelfManagedIoStart;

    //
    // Register the PnP and power callbacks. Power policy related callbacks will be registered
    // later in SotwareInit.
    //
    WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

	  //第二步：下面创建device

    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

	  //deviceAttributes在不但在创建设备对象时用，也在创建请求时用呢

    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device/*输出句柄*/);

    if (NT_SUCCESS(status)) {
        //
        // Get the device context and initialize it. WdfObjectGet_DEVICE_CONTEXT is an
        // inline function generated by WDF_DECLARE_CONTEXT_TYPE macro in the
        // device.h header file. This function will do the type checking and return
        // the device context. If you pass a wrong object  handle
        // it will return NULL and assert if run under framework verifier mode.
        //
		    //这里有个问题：为什么亲儿子只能通过这种方式见面？
        deviceContext = WdfObjectGet_DEVICE_CONTEXT(device);//亲儿子

        deviceContext->PrivateDeviceData = 0;//象征性设置一下，你懂的
		
        //第三步：创建接口

        // Create a device interface so that application can find and talk
        // to us.
        // 创建接口实例是是大事，问题是：创建的实例存在哪了？
        status = WdfDeviceCreateDeviceInterface(
            device,
            &GUID_DEVINTERFACE_ECHO, //在public.h定义，为何是public？有点意思
            NULL // ReferenceString，不会创建接口实例两次，不会有双胞胎
            );

        if (NT_SUCCESS(status)) {
            //
            // Initialize the I/O Package and any Queues
            //
            status = EchoQueueInitialize(device);
        }
    }

    return status;
}


//不宣称pageable是很有道理的，原因在上面解释中，用得到！
NTSTATUS
EchoEvtDeviceSelfManagedIoStart( //pnp回调
    IN  WDFDEVICE Device
    )
/*++

Routine Description:

    This event is called by the Framework when the device is started
    or restarted after a suspend operation.

    This function is not marked pageable because this function is in the
    device power up path. When a function is marked pagable and the code
    section is paged out, it will generate a page fault which could impact
    the fast resume behavior because the client driver will have to wait
    until the system drivers can service this page fault.

Arguments:

    Device - Handle to a framework device object.

Return Value:

    NTSTATUS - Failures will result in the device stack being torn down.

--*/
{
	  //因为有这语句：WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(QUEUE_CONTEXT, QueueGetContext)
	  //而且QueueGetContext都不用自己实现！
    PQUEUE_CONTEXT queueContext = QueueGetContext(WdfDeviceGetDefaultQueue(Device));

    LARGE_INTEGER DueTime;

    // Restart the queue and the periodic timer. We stopped them before going
    // into low power state.
    //
    WdfIoQueueStart(WdfDeviceGetDefaultQueue(Device)); //这么简单？

    DueTime.QuadPart = WDF_REL_TIMEOUT_IN_MS(100); //从宏看是100us，估计真的是100ms

    WdfTimerStart(queueContext->Timer,  DueTime.QuadPart);

    return STATUS_SUCCESS;
}


NTSTATUS
EchoEvtDeviceSelfManagedIoSuspend( //这个函数不允许返回失败
    IN  WDFDEVICE Device
    )
/*++

Routine Description:

    This event is called by the Framework when the device is stopped
    for resource rebalance or suspended when the system is entering
    Sx state.

    NTSTATUS - The driver is not allowed to fail this function.  If it does, the
    device stack will be torn down.

--*/
{
    PQUEUE_CONTEXT queueContext = QueueGetContext(WdfDeviceGetDefaultQueue(Device));

    PAGED_CODE();

	//为什么要保证没有未处理完的i/o？
	//答案：因为framework不能暂停设备，如果有request归属于driver的话
    //
    // Before we stop the timer we should make sure there are no outstanding
    // i/o. We need to do that because framework cannot suspend the device
    // if there are requests owned by the driver. There are two ways to solve
    // this issue: 1) We can wait for the outstanding I/O to be complete by the
    // periodic timer 2) Register EvtIoStop callback on the queue and acknowledge
    // the request to inform the framework that it's okay to suspend the device
    // with outstanding I/O. In this sample we will use the 1st approach
    // because it's pretty easy to do. We will restart the queue when the
    // device is restarted.
    //
    WdfIoQueueStopSynchronously(WdfDeviceGetDefaultQueue(Device));

    //
    // Stop the watchdog timer and wait for DPC to run to completion if it's already fired.
    // 
    WdfTimerStop(queueContext->Timer, TRUE); // Wait=TRUE,要等待，specifies that the framework does not return 
	                                         //until all queued calls to the timer's EvtTimerFunc callback function
	                                         //have executed.

    return STATUS_SUCCESS;
}


